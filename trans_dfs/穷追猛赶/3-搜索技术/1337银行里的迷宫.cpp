
/*
  楚楚每一次都在你的帮助下过了一关又一关(比如他开宴会)。这一次，你的才华让楚楚被劫住了！(好心办了坏事啊，下次不理他了=_=)

       歹徒： hehe~

       楚楚：(冷汗ing)干啥^_^！(PS：现在还笑得出来！！！)

       歹徒：抢劫的说~

       楚楚：你们想干啥！！(PS：不是告诉你了，是抢劫~)

       歹徒：这里是银行的陷阱,也就是一个迷宫……你要带我们离开这里……否则……

       楚楚：(想：那你是咋抓到我的，郁闷)好吧……

       楚楚认为生命还是最重要的……(大不了出去以后找警察……)

       于是，他认命了……

       他从歹徒口中得知这是一个方形的迷宫(歹徒老大：你还要啥形状的，跟我说一声！)，他们的位置是[1,1]，要走到[n,m],长是n，宽是m，这是一个很大的迷宫，里面有陷阱(小明：能不能踩进去的，说！楚楚：当然不能，不过可以用轻功，多花一秒蓄力~用轻功走过的陷阱会石化，变成路，而且刚好走过~ 歹徒想：虾米轻功~明明是杀人利器~还好没和他打起来~)，还有墙(PS：说一声，墙不能穿过，虽有轻功，但是还是过不去墙，这个墙也是银行的秘密~即使你是神囊膊恍信~ 楚楚：又坑我~)。(小明：路呢？ 楚楚：废话，当然有，只不过这是银行机密，不能说！)

       楚楚想在最短时间里走出迷宫(小明：否则歹徒会发怒的，对不对？ 楚楚：废话！)，若是超过了歹徒老大的忍耐时间time，那就……

       (楚楚：小明……SOS，别忘了帮我报警！！ 传呼机：嘀，嘀，嘀…… 楚楚：咋么可以这样！可恶！)于是，他顺便还要去找电话报个警(报警不需要时间，打通即可。且电话机可能有多个，但也没有可能没有~)。

楚楚：我的预感告诉我，这个迷宫只能向右或下走~郁闷了~
输入描述 Input Description

       第1行是n,m, time，三个整数。

       第2到n+1行每行有m个字母(有大写也有小写的)(楚楚：歹徒真笨~，就不能翻译一下吗~)。

       字母解析：T(t)是陷阱，W(w)是墙，R(r)是路，A(a)是电话~ (遇到不认识的字符就~算之为路！)
输出描述 Output Description

       仅一行走出迷宫的最小时间t(走一步要一秒的说)，不能在规定时间走出迷宫，或者打不了电话，请输出“Oh my god!”(不包括引号)。
样例输入 Sample Input

3 3 100

RRR

WWA

TRR
样例输出 Sample Output

4
*/
    //动态规划，由已知步数求未知步数 (参考，源代码属于“忆_碎碎念”)  
    #include <cstdio>  
    #include <cstring>  
    #include <algorithm>  
    #include <cmath>  
    #include <vector>  
    #include <cctype>  
    #include <climits>  
    using namespace std;  
      
    #define BIGNUM 25000000  
    char str[505][505];  
    int dp[505][505];  
    int n, m, limit;  
    bool phone = false;  
    int main()  
    {  
     scanf("%d%d%d", &n, &m, &limit);  
     for(int i = 1; i <= n; i++)  
      for(int j = 1; j <= m; j++)  
      {  
       scanf(" %c", &str[i][j]);  
       str[i][j] = toupper(str[i][j]);  
      }  
     if(str[1][1] == 'W' || str[n][m] == 'W' || str[1][1] == 'T' || str[n][m] == 'T')  
     {  
      printf("Oh my god!");  
      exit(0);  
     }  
     else  
     {  
      for(int i = 1; i <= n; i++)  
      {  
       for(int j = 1; j <= m; j++)  
       {  
        if(i == 1 && j == 1)//起点不做计算   
         continue;  
        dp[i][j] = BIGNUM;//赋值为很大的值，为了便于后面计算步数   
        if(str[i][j] == 'W')//碰见墙就不做计算 ，直接返回   
         continue;  
        if(str[i][j] == 'A')  
         phone = true//有一次出现电话了就标记一下   
         //因为题设只有两种走法，向下或向右，那么假如到了一个坐标，那么只能从左边过来或者是从上边过来  
         //只要现在的远远大于原来的，就说明原来可能从那里经过，所以本格加上次的时间再加一次这次的时间  
         //就是 dp[i][j] = dp[i - 1][j] + 1;或 dp[i][j] = dp[i][j - 1] + 1;  
        //如果是陷阱就要多加一次 dp[i][j]++;  
        if(i - 1 >= 1 && dp[i - 1][j] < dp[i][j])   
         dp[i][j] = dp[i - 1][j] + 1;  
        if(j - 1 >= 1 && dp[i][j - 1] < dp[i][j])  
         dp[i][j] = dp[i][j - 1] + 1;  
        if(str[i][j] == 'T')  
         dp[i][j]++;  
       }  
      }  
     }  
     if(phone && dp[n][m] <= limit)  
      printf("%d", dp[n][m]);  
     else  
      printf("Oh my god!");  
     return 0;  
    }  