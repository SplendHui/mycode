算法特征:
    
    1.有穷性
    2.确定性
    3.可行性
    4.可以没有输入,但是一定有输出运算项目


算法实现的三要素:
    数据
    运算
    控制

数据结构:

    队列(优先队列,循环队列,普通队列)
    栈(顺序栈,链栈)
    链表(单向链表, 双向链表, 双向循环链表)
        1. 用C++ 实现 线性表, 栈, 队列(循环链表).
        2. 等价类问题.
        3. 电路板问题,无非就是广度搜索,利用前驱记录路径即可
        c++ cout << 1.0 << endl 输出的结果是 1 默认会把后面的0拿掉.
    排序:
        排序类问题,给定一个序列,每一步的过程是咋样的
        冒泡排序
        选择排序
        直接插入排序
        shell排序
        合并排序
        堆排序
            原理:
                构造一个大根堆或者小根堆
        快速排序
        计数排序

    树:
        二叉树的性质:
            1.二叉树第 i 层最多拥有 2的i-1次方个节点
            2.深度为 k 的二叉树至多 2的k次方减1个节点
            3.终端节点数n0 = n2 + 1 n2为度数为2的节点数
            4.n个节点的完全二叉树深度为logn-1
        二叉树存储结构
            1. 顺序存储结构
            2. 链表存储结构,包括左右孩子指针,甚至还有父节点指针.
                n个节点的二叉链表有n+1个空链表
        二叉树遍历:
            1.先序遍历: 根左右
            2.中序遍历: 左根右
            3.后序遍历: 左右根
        二叉树的还原:
            通过先序和中序可以求出原始二叉树
            通过中序和后序可以求出原始二叉树
            但是通过先序和后序无法还原出二叉树
        树的存储结构:
            1.双亲表示法: 存储父亲节点
            2.孩子表示法: 每个节点中存在多个节点,如何预先设定节点个数,度数为k的树则浪费n(k-1)+1个空链接域,
                如何用链表则操作复杂.
            3.孩子兄弟表示法: 通过firstchild找到第一个孩子,再通过nextsibling i-1步骤获取第i个孩子
    图:

        图的一些基本概念:
            顶点 v到w的一条弧 v为弧尾, w为弧头. (v,w)为一条边. 有向图, 无向图
            无向图的边数e 为0到1/2n(n-1) 无向完全图 n(n-1)的为有向完全图.
            边少的图(e<nlogn) 称为稀疏图, 反之稠密图. 与边相关的数叫权重.
            子图. 定点数和边数都在原集合中的.
            顶点的度, 出度和入度,一个顶点的度为出度加入度. 边数e = 1/2 * 所有度数.
            两个顶点有路径可达,则说明是连通的. 任意两个顶点都连通为强连通图.
            生成树是一个极小连通子图(含有所有顶点)
            n个顶点的图,边数大于n-1则一定有环, n-1条边不一定是生成树
        
        图的存储结构:
            矩阵(构造时间复杂度O(n*n + n*e))
            邻接表(邻接表适合于边稀疏图 e<< n*(n-1)/2) (如果顺序建表时间(n+e))否则O(n*e)
                缺点: 判断两个顶点是否有边要搜索某个链表,不如矩阵方便
            十字链表复杂度和邻接表一样.
        图的,一个图的最小生成树.